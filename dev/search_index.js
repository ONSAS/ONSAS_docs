var documenterSearchIndex = {"docs":
[{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#Static-Von-Mises-Truss-example","page":"Static Von-Mises Truss","title":"Static Von Mises Truss example","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"In this tutorial, the Static Von Mises Truss example and its resolutions using ONSAS are described. The aim of this example is to validate the Newton-Raphson and the Arc-Length methods implementation by comparing the results provided by ONSAS with the analytical solution.","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The structural model is formed by two truss elements as it is shown in the figure, with the node 2 submitted to a nodal load P and restrained to movement in the x-z plane and nodes 1 and 3 fixed.","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"(Image: structure diagram)","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The Octave script is avaiable at: RUTA","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar auxiliar parameters are defined.","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"close all, clear all ;\naddpath( [ pwd '/../../src'] ); \nE = 210e9 ;  A = 2.5e-3 ; ang1 = 65 ; L = 2 ; nu = 0 ;\nauxx = cos( ang1*pi/180 ) * L ;  auxz = sin( ang1*pi/180 ) * L ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#MEBI-parameters","page":"Static Von-Mises Truss","title":"MEBI parameters","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions-InitialConditions (MEBI) parameters.","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#materials","page":"Static Von-Mises Truss","title":"materials","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"Since both bars are formed by the same material all the fields of the materials struct will have only one entry. contains only one vector. The constitutive behavior is the SaintVenantKirchhoff:","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"materials.hyperElasModel  = { 'SVK'} ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"and the parameters of this model are the Lamé parameters","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"lambda = E*nu/((1+nu)*(1-2*nu)) ; mu = E / (2*(1+nu));\nmaterials.hyperElasParams = { [ lambda  mu  ] } ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#elements","page":"Static Von-Mises Truss","title":"elements","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"Two different types of elements are considered, node and truss. The nodes will be assigned in the first entry (index 1) and the truss at the index 2. The elemType field is then:","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"elements.elemType = { 'node','truss' } ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"for the geometries, the node has not geometry to assign (empty array), and the truss elements will be set as a square-cross section, then the elemTypeGeometry field is:","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"elements.elemTypeGeometry = { [], [2 sqrt(A) sqrt(A) ] };\nelements.elemTypeParams = { [], 1 };","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#boundaryConds","page":"Static Von-Mises Truss","title":"boundaryConds","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The elements are submitted to two different BC settings. The nodes 1 and 3 are fixed without applied loads (first BC), and node 2 has a constraint in displacement and an applied load (second BC).","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"boundaryConds.loadCoordSys = { []        ; 'global'   } ;\nboundaryConds.loadTimeFact = { []        ; @(t) 1.5e8*t     } ;\nboundaryConds.loadBaseVals = { []        ; [ 0 0 0 0 -1 0 ] } ;\nboundaryConds.impoDispDofs = { [ 1 3 5 ] ; 3          } ;\nboundaryConds.impoDispVals = { [ 0 0 0 ] ; 0          } ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#initial-Conditions","page":"Static Von-Mises Truss","title":"initial Conditions","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"homogeneous initial conditions are considered, then an empty struct is set:","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"initialConds                = struct() ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#mesh-parameters","page":"Static Von-Mises Truss","title":"mesh parameters","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The coordinates of the nodes of the mesh are given by the matrix:","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.nodesCoords = [      0  0     0  ; ...\n                       auxx  0  auxz  ; ...\n                     2*auxx  0     0  ] ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"The connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell = { } ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"then the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. No non-homogeneous initial condition is considered (then zero is used) and finally the node is included.","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1   ] ; \nmesh.conecCell{ 2, 1 } = [ 0 1 1 0  3   ] ; ","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"the following case only differs in the boundary condition","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell{ 3, 1 } = [ 0 1 2 0  2   ] ; ","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"the truss elements are formed by the first material, the second type of element, and no boundary condition is applied.","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"mesh.conecCell{ 4, 1 } = [ 1 2 0 0  1 2 ] ;\nmesh.conecCell{ 5, 1 } = [ 1 2 0 0  2 3 ] ; ","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#analysisSettings","page":"Static Von-Mises Truss","title":"analysisSettings","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"analysisSettings.methodName    = 'newtonRaphson' ;\nanalysisSettings.deltaT        = 0.1 ;\nanalysisSettings.finalTime     =   1 ;\nanalysisSettings.stopTolDeltau =   1e-6 ;\nanalysisSettings.stopTolForces =   1e-6 ;\nanalysisSettings.stopTolIts    =   10 ;\nanalysisSettings.finalTime     =   1 ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#otherParams","page":"Static Von-Mises Truss","title":"otherParams","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"otherParams.problemName = 'staticVonMisesTruss_NR';\notherParams.plotParamsVector = [3];\notherParams.controlDofs = [2 5 ];","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/#ONSAS-execution","page":"Static Von-Mises Truss","title":"ONSAS execution","text":"","category":"section"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"[matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"```","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"analyticFunc    = @(w) 2 * E * A * sin(ang1 * pi / 180 )^2 * w / L ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"numDisp =  -matUs(11,:) ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"figure plot( numDisp , loadFactorsMat(:,2) ,'b' ) hold on, grid on plot( numDisp , analyticFunc( numDisp),'r' )","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"l0           = sqrt(auxx^2 + auxz^2) ; analyticFunc = @(w) -2 * EA ( (  (auxz+(-w)).^2 + auxx^2 - l0^2 ) ./ (l0 * ( l0 + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ...             .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  hold on, grid on plot( numDisp , analyticFunc( numDisp), 'g' )","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"% =============================================== % methods comparison % ==================================== % second case: newton raphson analysis % =============================================== % third case: NRarc-length analysis with dxf mesh % ––––––––––––––––––––––––––––––––––– % –- plots – %l0           = sqrt(auxx^2 + auxz^2) ; % analyticFunc = @(w) -2 * EA ( (  (auxz+(-w)).^2 + auxx^2 - l0^2 ) ./ (l0 * ( l0 + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ... % .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  % %% analytical solution using engineering strain % analyticFunc = @(w)  -2 * EA ( (  (auxz+(-w)).^2 + auxx^2 - l0^2 ) ./ (l0 * ( l0 + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ...  %~ .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  % %~ lw = 2.0 ; ms = 11 ; plotfontsize = 22 ; %~ figure %~ plot( controlDispsNRAL, analyticNRAL ,'b-x' , 'linewidth', lw,'markersize',ms ) %~ hold on, grid on %~ plot( controlDispsNRAL, loadFactorsNRAL,'r-s' , 'linewidth', lw,'markersize',ms ) %~ plot( controlDispsNR, loadFactorsNR,'k-o' , 'linewidth', lw,'markersize',ms ) %~ labx = xlabel('Displacement');   laby = ylabel('lambda') ; %~ legend('analytic','NRAL-DXF','NR','location','North') %~ set(gca, 'linewidth', 1.2, 'fontsize', plotfontsize ) %~ set(labx, 'FontSize', plotfontsize); set(laby, 'FontSize', plotfontsize) ;","category":"page"},{"location":"tutorials/StaticVonMisesTruss/staticVonMisesTruss/","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss","text":"%~ [verifBoolean, numericalVals, analyticVals] = analyticSolVerif ...     %~ ( analytSol, analyticFunc, loadFactors, controlDisps, timesVec, ...     %~ analyticCheckTolerance, analyticSolFlag, problemName, printFlag, outputDir, plotParamsVector );","category":"page"},{"location":"tutorials/HeatDiffusion/heat/#Heat-diffusion","page":"Heat diffusion","title":"Heat diffusion","text":"","category":"section"},{"location":"tutorials/HeatDiffusion/heat/#Introduction","page":"Heat diffusion","title":"Introduction","text":"","category":"section"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"nabla cdot (k nabla T) + Q_h = ρ c dotT","category":"page"},{"location":"tutorials/HeatDiffusion/heat/#Variational-formulation","page":"Heat diffusion","title":"Variational formulation","text":"","category":"section"},{"location":"tutorials/HeatDiffusion/heat/#Finite-element-formulation","page":"Heat diffusion","title":"Finite-element formulation","text":"","category":"section"},{"location":"tutorials/HeatDiffusion/heat/#One-dimensional-example","page":"Heat diffusion","title":"One-dimensional example","text":"","category":"section"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"Let us consider the one-dimensional heat equation, partial_t T(x t) = alpha partial^2_xxT(x t) where alpha = k  rho c is assumed uniform in the domain 01 and constant. Q_h = 0 is also assumed. The boundary conditions are given by Dirichlet conditions at both boundaries T(0t) = 0 and T(1t)=0 for all times. The initial condition is given by the following temperature distribution function:","category":"page"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"T(x t=0) = phi(x) = sin pi x + frac12sin 3pi x","category":"page"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"using Plots, LaTeXStrings\n\nϕ(x) = sin(π*x) + sin(3π*x)/2\n\nne = 50 # number of elements\nxdom = 0:1/ne:1\nT0 = ϕ.(xdom)\n\nplot(0:1e-3:1, ϕ, seriestype=:line, lab=L\"\\phi(x)\",\n     xlab=L\"x\", ylab=L\"T\", legend=:bottomright, title=\"Initial temperature profile\")\nplot!(xdom, T0, seriestype = :scatter, lab=L\"T(x=x_e, 0)\")\n#savefig(\"plot_initial_temperature.svg\")\n\nnothing","category":"page"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"(Image: )","category":"page"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"The analytic solution in this case is","category":"page"},{"location":"tutorials/HeatDiffusion/heat/","page":"Heat diffusion","title":"Heat diffusion","text":"T(x t) = e^- pi^2 alpha tsin pi x + frac12e^-(3pi)^2 alpha tsin 3pi xqquad 0 leq x leq 1 t geq 0","category":"page"},{"location":"theory/prinTherWork/#Principle-of-Virtual-Thermal-Work","page":"Virtual thermal work","title":"Principle of Virtual Thermal Work","text":"","category":"section"},{"location":"theory/prinTherWork/#Variational-formulation-of-the-heat-flow-equation","page":"Virtual thermal work","title":"Variational formulation of the heat flow equation","text":"","category":"section"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"    int_Omega k nabla T cdot nabla delta T dV\n  + int_Omega rho c fracpartial Tpartial t delta T dV\n  =\n    int_Omega Q_h delta T d V\n  + int_partial Omega k nabla T cdot hatmathbfn delta T d S \n qquad forall delta T in tildemathcalT","category":"page"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"Considering the boundary conditions","category":"page"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"left\nbeginarraylr\nT(mathbfxt) = f_D(t)  texton Gamma_D \n-k fracpartial Tpartial n (mathbfxt) = f_N(mathbfxt)  texton  Gamma_N \n-k fracpartial Tpartial n (mathbfxt) = h left( T(mathbfxt)-T_infty(t) right)   texton  Gamma_R\nendarray\nright","category":"page"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"where h is the convection coefficient and T_infty(t) is the ambient temperature at time t.","category":"page"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"    int_Omega k nabla T cdot nabla delta T dV\n  + int_Omega rho c fracpartial Tpartial t delta T dV\n  + int_Gamma_R h T(mathbfxt) delta T d S \n  =\n    int_Omega Q_h delta T d V\n  + int_Gamma_N q_inp(mathbfxt)  delta T d S \n  + int_Gamma_R h T_infty(t) delta T d S \n\n qquad forall delta T in tildemathcalT","category":"page"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"where q_inp is the input heat flow q_inp = -f_N.","category":"page"},{"location":"theory/prinTherWork/#Finite-Elements","page":"Virtual thermal work","title":"Finite Elements","text":"","category":"section"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"mathbfK_diff^e = frac k^e A^eell^e \nleft\nbeginmatrix\n1  -1 \n-1  1\nendmatrix\nright","category":"page"},{"location":"theory/prinTherWork/","page":"Virtual thermal work","title":"Virtual thermal work","text":"mathbfC_intE^e = rho^e c^e A^e ell^e frac16 \nleft\nbeginmatrix\n2  1 \n1  2\nendmatrix\nright","category":"page"},{"location":"about/#Authors","page":"About","title":"Authors","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The following authors collaborated in various tasks including: design, development and testing of the code.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Jorge M. Pérez Zerpa [1], leaded and managed the design and development of the code, developed the assembly functions, nonlinear truss element formulation, nonlinear static analysis function, designed and co-authored Newmark's method function, input and output functions, leaded the generation of the documentation.\nJ. Bruno Bazzano[1], [2], leaded the development of the nonlinear/linear buckling analysis modules, co-designed the code, developed and implemented validation examples, validated the HHT implementation.\nJoaquín Viera [1], leaded the development of the Linear Analysis module and input files, collaborated in the design and development of the input reading and output generation modules, leaded the development of GUI.\nMauricio Vanzulli [4] co-developed the Newmark's method functions and scripts, developed input files for the dynamic analysis examples.\nMarcelo Forets[6] developed the Neo-Hookean solid model.","category":"page"},{"location":"about/","page":"About","title":"About","text":"The following authors contributed by :","category":"page"},{"location":"about/","page":"About","title":"About","text":"Jean-Marc Battini[3], contributed functions associated with the computation of static internal forces of the nonlinear frame element.\nSebastian Toro[5], provided the functions: fLectDxf.m, fValGrCode.m and f_XData.m, used in the dxf import function.","category":"page"},{"location":"about/","page":"About","title":"About","text":"[1]: Instituto de Estructuras y Transporte, Facultad de Ingeniería, Universidad de la República, Montevideo, Uruguay","category":"page"},{"location":"about/","page":"About","title":"About","text":"[2]: Bazzano & Scelza Ingenieros, Montevideo, Uruguay","category":"page"},{"location":"about/","page":"About","title":"About","text":"[3]: Department of Civil and Architectural Engineering, KTH Royal Institute of Technology, Stockholm, Sweden","category":"page"},{"location":"about/","page":"About","title":"About","text":"[4]: Instituto de Ingeniería Mecánica y Producción Industrial, Facultad de Ingeniería, Universidad de la República, Montevideo, Uruguay.","category":"page"},{"location":"about/","page":"About","title":"About","text":"[5]: CIMEC Santa Fe, Argentina","category":"page"},{"location":"about/","page":"About","title":"About","text":"[6]: Centro Universitario Regional Este, Universidad de la República, Maldonado, Uruguay","category":"page"},{"location":"about/#Contributions-and-Acknowledgments","page":"About","title":"Contributions and Acknowledgments","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"The functions in linearStiffMatPlate3D.m and assemblyUniform.m use part of the femplateexample.m code developed by Jorge Pérez Zerpa and Pablo Castrillo.","category":"page"},{"location":"about/","page":"About","title":"About","text":"J. M. Pérez Zerpa would like to thank: Pablo Blanco  from the hemolab.lncc.br group at LNCC Brazil,  Gonzalo Ares from Univ. Nacional de Mar del Plata, Gonzalo Maso Talou from  the Auckland Bioengineering Institute and Diego Figueredo  for their numerous comments and suggestions.","category":"page"},{"location":"about/","page":"About","title":"About","text":"The development of ONSAS has been partially supported by funds provided by the following agencies/projects:  Comisión de Investigación Científica (CSIC), Comisión Sectorial de Enseñanza (project: Rediseño de prácticas de enseñanza y evaluación en Resistencia de Materiales, manager, Prof. Pérez Zerpa), Agencia Nacional de Investigación e Innovación  (project VIOLETA, code FSE_1_2016_1_131837, manager, Prof. Usera.","category":"page"},{"location":"about/#Contact","page":"About","title":"Contact","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"You can send an e-mail to jorgepz[AT]fing.edu.uy .","category":"page"},{"location":"about/#Affiliations","page":"About","title":"Affiliations","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/#Simple-pendulum","page":"Simple pendulum","title":"Simple pendulum","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/#Model","page":"Simple pendulum","title":"Model","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/","page":"Simple pendulum","title":"Simple pendulum","text":"In this tutorial we study a simple pendulum. The model has one truss element. This model is taken from [BAT14].","category":"page"},{"location":"tutorials/SimplePendulum/simple_pendulum/","page":"Simple pendulum","title":"Simple pendulum","text":"Parameter Value\nEs 10e11\nnu 0\nA 0.1\nl0 3.0443\nm 10\ng 9.81","category":"page"},{"location":"tutorials/SimplePendulum/simple_pendulum/#Result","page":"Simple pendulum","title":"Result","text":"","category":"section"},{"location":"tutorials/SimplePendulum/simple_pendulum/","page":"Simple pendulum","title":"Simple pendulum","text":"note: TO-DO\nAdd results.","category":"page"},{"location":"howtouse/functions/#list-of-ONSAS.m-functions","page":"list of ONSAS.m functions","title":"list of ONSAS.m functions","text":"","category":"section"},{"location":"howtouse/functions/","page":"list of ONSAS.m functions","title":"list of ONSAS.m functions","text":"This is a list of all the .m functions of the ONSAS Octave implementation:","category":"page"},{"location":"howtouse/functions/","page":"list of ONSAS.m functions","title":"list of ONSAS.m functions","text":"checkOrSetDefault.m\ncrossSectionProps.m\nelem2NodalLoads.m\nmyCell2Mat.m\nnodes2dofs.m\nONSAS.m","category":"page"},{"location":"howtouse/creatingModels/#Creating-structural-models","page":"Creating Models","title":"Creating structural models","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The data and properties of each structural model are defined through a set of definitions in a .m script. These properties are stored in struct data structures. The following structs must be defined and provided as input to the ONSAS function in this order:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"materials\nelements\nboundaryConds\ninitialConds\nmesh\nnumericalMethod\notherParams","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"Each struct has its own fields with specific names, used to store each corresponding property or information. Each field is obtained or assiged using structName.fieldName. A description of each struct and its fields follows at next.","category":"page"},{"location":"howtouse/creatingModels/#The-materials-struct","page":"Creating Models","title":"The materials struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The materials struct contains the information of the material behavior considered for each element.","category":"page"},{"location":"howtouse/creatingModels/#material.hyperElasModel","page":"Creating Models","title":"material.hyperElasModel","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"This is a cell array with the string-names of the material models used, the options for these names are:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"'linearElastic': for linear behaviour in small strains and displacements. The scalar parameters of this model are p_1=E the Young modulus and p_2=nu the Poisson's ratio.\n'SVK': for a Saint-Venant-Kirchhoff material where the parameters p_1 and p_2 are the Lamé parameters and textbfE is the Green-Lagrange strain tensor, with the strain-energy density function given by","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"Psi( textbfE ) = fracp_12 tr(textbfE)^2 + p_2 tr(textbfE^2)\nquad\np_1 = frac E nu  (1+nu) (1-2nu) \nquad\np_2 = frac E  2 (1+nu) ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"'NHC': for a Neo-Hookean compressible material","category":"page"},{"location":"howtouse/creatingModels/#materials.hyperElasParams","page":"Creating Models","title":"materials.hyperElasParams","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"A cell structure with vectors with the material properties of each material used in the model. The i-th entry of the cell, contains a vector like this:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":" p_1 dots p_n_P ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"where n_P is the number of parameters of the constitutive model and mathbfp is the vector of constitutive parameters.","category":"page"},{"location":"howtouse/creatingModels/#The-elements-struct","page":"Creating Models","title":"The elements struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The elements struct contains the information about the type of finite elements used and their corresponding parameters.","category":"page"},{"location":"howtouse/creatingModels/#elements.elemType","page":"Creating Models","title":"elements.elemType","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell structure with the string-names of the elements used: node, truss, frame or tetra.","category":"page"},{"location":"howtouse/creatingModels/#elements.elemTypeGeometry","page":"Creating Models","title":"elements.elemTypeGeometry","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell structure with the information of the geometry of the element. For truss or frame elements a vector with the cross-section properties is required:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":" crossSectionType  crossSectionParam_1 dots crossSectionParam_n","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"with n being the number of parameters of the cross section type, and crossSectionType taking values: 1 (for general sections with given area and interias), 2 (for rectangular sections with given with thicknesses t_y and t_z) and 3 (for circular sections with given diameter). See the crossSectionProps.m function for more details.","category":"page"},{"location":"howtouse/creatingModels/#The-boundaryConds-struct","page":"Creating Models","title":"The boundaryConds struct","text":"","category":"section"},{"location":"howtouse/creatingModels/#boundaryConds.loadsCoordSys","page":"Creating Models","title":"boundaryConds.loadsCoordSys","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell containing the coordinates system for the loads applied in each BC, each entry should be a 'global' string or a 'local', or an empty array if no load is applied in that BC setting [].","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.loadsTimeFact","page":"Creating Models","title":"boundaryConds.loadsTimeFact","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with the inline function definitions of load factors of the loads applied of an empty array.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.loadsBaseVals","page":"Creating Models","title":"boundaryConds.loadsBaseVals","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with the vector of the components of the load case","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":" f_x   m_x  f_y  m_y  f_z  m_z ","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.userLoadsFileName","page":"Creating Models","title":"boundaryConds.userLoadsFileName","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with filenames of .m function file provided by the user that can be used to apply other forces.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.imposDispDofs","page":"Creating Models","title":"boundaryConds.imposDispDofs","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the local degrees of freedom imposed (integers from 1 to 6)","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.imposDispVals","page":"Creating Models","title":"boundaryConds.imposDispVals","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the values of displacements imposed.","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.springsDofs","page":"Creating Models","title":"boundaryConds.springsDofs","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the local degrees of freedom with springs (integers from 1 to 6)","category":"page"},{"location":"howtouse/creatingModels/#boundaryConds.springsVals","page":"Creating Models","title":"boundaryConds.springsVals","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell with vectors of the values of the springs stiffnesses.","category":"page"},{"location":"howtouse/creatingModels/#The-initialConds-struct","page":"Creating Models","title":"The initialConds struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"It initial conditions are homogeneous, then an empty struct should be defined initialConds = struct() ;.","category":"page"},{"location":"howtouse/creatingModels/#initialConds.nonHomogeneousInitialCondU0","page":"Creating Models","title":"initialConds.nonHomogeneousInitialCondU0","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"matrix to set  the value of displacements at the time step t=0. [default: []]","category":"page"},{"location":"howtouse/creatingModels/#initialConds.nonHomogeneousInitialCondUdot0","page":"Creating Models","title":"initialConds.nonHomogeneousInitialCondUdot0","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"matrix to prescribe the value of velocities at the time step t=0. [default: []]","category":"page"},{"location":"howtouse/creatingModels/#The-mesh-struct","page":"Creating Models","title":"The mesh struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"The mesh struct contains the finite element mesh information.","category":"page"},{"location":"howtouse/creatingModels/#mesh.nodesCoords","page":"Creating Models","title":"mesh.nodesCoords","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"matrix with the coordinates of all the nodes of the mesh. The i-th row contains the three coordinates of the node i: x_i   y_i  z_i,","category":"page"},{"location":"howtouse/creatingModels/#mesh.conecCell","page":"Creating Models","title":"mesh.conecCell","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"cell array with the elements and node-connectivity information. The i1 entry contains the vector with the MEBI (Material, Element, boundaryConds and initialConds) indexes and the nodes of the i-th element. The structure of the vector at each entry of the cell is:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"  materialInd  elementInd  boundaryCondInd  initialCondInd  node_1 dots node_n ","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"where the five indexes are natural numbers and n is the number of nodes required by the type of element. If noproperty is assigned the 0 index can be used, for instance, nodes used to introduced loads should be defined with materialIndex = 0.","category":"page"},{"location":"howtouse/creatingModels/#The-analysisSettings-struct","page":"Creating Models","title":"The analysisSettings struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"This struct contains the parameters required to apply the numerical method for the resolution of the nonlinear equations:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"methodName: string with the name of the method used: 'newtonRaphson','arcLength','newmark','alphaHHT'.\nstopTolDeltau: float with tolerance for convergence in relative norm of displacements increment\nstopTolForces: float with tolerance for convergence in relative norm of residual loads\nstopTolIts: integer with maximum number of iterations per time step\ndeltaT: time step\nfinalTime: final time of simulation\nincremArcLen: with of cylinder for arcLength method\ndeltaNM: delta parameter of newmark method\nalphaNM: alpha paramter of newmark method\nalphaHHT: alpha parameter of alpha-HHT method","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"another additional optional parameters are:","category":"page"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"nodalDispDamping: scalar value of linear external viscous damping for the displacements degrees of freedom [default: 0]\niniMatUs: a matrix with initial solutions for each time step.","category":"page"},{"location":"howtouse/creatingModels/#The-otherParams-struct","page":"Creating Models","title":"The otherParams struct","text":"","category":"section"},{"location":"howtouse/creatingModels/","page":"Creating Models","title":"Creating Models","text":"problemName: string with the name of the problem, to be used in outputs.\nplotParamsVector: 3 for vtk output\ncontrolDofs: matrix with information of the degrees of freedom to compute and control. Each row should contain this form: [ node localdof ].\nstoreBoolean: boolean to store the results of the current iteration such as the displacements, tangent matrices, normal forces and stresses. [default: 1]","category":"page"},{"location":"howtouse/install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"howtouse/install/#Running-ONSAS.m","page":"Installation","title":"Running ONSAS.m","text":"","category":"section"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"The user should follow these steps to install and run ONSAS:","category":"page"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"Download and install the latest version of GNU-Octave.\nDownload the zip file of the latest ONSAS release from these site.\nOpen GNU-Octave and run one of the example scripts from the examples folder (or create yours!).","category":"page"},{"location":"howtouse/install/#Visualizing-results","page":"Installation","title":"Visualizing results","text":"","category":"section"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"You can process the outputs using Octave, however, the open-source software ParaView can be used to visualize the results produced by ONSAS.","category":"page"},{"location":"howtouse/install/#Generation-of-geometries/meshes","page":"Installation","title":"Generation of geometries/meshes","text":"","category":"section"},{"location":"howtouse/install/","page":"Installation","title":"Installation","text":"The user can provide the geometry of the structure using two optional formats: .msh or .dxf.  GMSH is an open-source tool that allows to generate high-quality meshes. The dxf files can be used using any CAD tool.","category":"page"},{"location":"theory/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"theory/references/","page":"References","title":"References","text":"","category":"page"},{"location":"theory/references/#[BAT14]","page":"References","title":"[BAT14]","text":"","category":"section"},{"location":"theory/references/","page":"References","title":"References","text":"Klaus-Jurgen Bathe.  Finite Element Procedures . 2014.","category":"page"},{"location":"theory/references/","page":"References","title":"References","text":"","category":"page"},{"location":"theory/references/#[BPZ17]","page":"References","title":"[BPZ17]","text":"","category":"section"},{"location":"theory/references/","page":"References","title":"References","text":"J. B. Bazzano and J. Perez Zerpa.  Introducción al Análisis No Lineal de Estructuras. 2017.","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/#Uniaxial-Extension-Solid","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"","category":"section"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/#The-problem","page":"Uniaxial Extension Solid","title":"The problem","text":"","category":"section"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"In this tutorial an elastic Saint-Venant-Kirchhoff solid submitted to a uniaxial loading test is considered. The geometry is given by a rectangular cuboid with dimensions L_x=1, L_y=1 and L_z=1, and a tension vector p = 3 textbfe_x is applied on the face at x=L_x.","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/#The-ONSAS-example-file","page":"Uniaxial Extension Solid","title":"The ONSAS example file","text":"","category":"section"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"The main features of the onsasExample_uniaxialExtension.m file are described in this section.","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/#MELCS-parameters","page":"Uniaxial Extension Solid","title":"MELCS parameters","text":"","category":"section"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"Before creating the finite element mesh discretization, the MELCS parameters shall be defined. The material properties of the model are defined by","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"materialsParams = {[ 0 2 E nu ]} ;","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"where the first entry of the vector is the density (considered zero), the second is the constitutive behavior (2 for SVK material) and E = 1 and nu = 03 are the constitutive parameters of the SVK model.","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"For the elements, two types of elements are used in the model: triangles (number 5) for loading and spring boundary conditions, and tetrahedra (number 4).","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"elementsParams = { [ 5   ] ; ...\n                   [ 4 2 ] } ; % analytic constitutive tensor","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"where the second entry of the vector in the second entry of the cell is the flag corresponding to the method for computation of the constitutive matrix (2 for analytical).","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"loadsParams = {[ 1 1  p 0 0 0 0 0 ]} ;  % global coords tension applied","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"crossSecsParams = cell(1,1) ; %","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"springsParams = {[ inf 0  0   0   0   0 ] ; ...\n                 [ 0   0  inf 0   0   0 ] ; ...\n                 [ 0   0  0   0   inf 0 ] } ;\n","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/#Mesh","page":"Uniaxial Extension Solid","title":"Mesh","text":"","category":"section"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"The solid is discretized using a mesh formed by 8 nodes with the following coordinates matrix","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"Nodes = [ 0    0    0 ; ...\n          0    0   Lz ; ...\n          0   Ly   Lz ; ...\n          0   Ly    0 ; ...\n          Lx   0    0 ; ...\n          Lx   0   Lz ; ...\n          Lx  Ly   Lz ; ...\n          Lx  Ly    0 ] ;","category":"page"},{"location":"tutorials/uniaxialExtension/uniaxialExtension/","page":"Uniaxial Extension Solid","title":"Uniaxial Extension Solid","text":"(Image: )","category":"page"},{"location":"theory/prinMechWork/#Principle-of-Virtual-Mechanical-Work","page":"Virtual mechanical work ","title":"Principle of Virtual Mechanical Work","text":"","category":"section"},{"location":"theory/prinMechWork/#Variational-formulation-of-the-principle","page":"Virtual mechanical work ","title":"Variational formulation of the principle","text":"","category":"section"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"ONSAS can be used to solve the set of nonlynear equations given by the Principle of Virtual Work (PVW). The PVW can be defined in terms of the following set of nonlinear equations:","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"left(\n     mathbff_mas(mathbfu_t dotmathbfu_t ddotmathbfu_t) \n  +  mathbff_vis(dotmathbfu_t) \n  +  mathbff_int(mathbfu_t)\n  -  mathbff_ext(t)\nright) cdot delta mathbfu \n=\n0 qquad forall delta mathbfu in tildemathcalU","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"The PVT is given by:","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"left(\nnabla cdot ( k nabla T ) + Q_h  - rho c fracpartial Tpartial t\nright) delta T =\n0 qquad forall delta T in tildemathcalT","category":"page"},{"location":"theory/prinMechWork/#Solid-Elements-Implementation","page":"Virtual mechanical work ","title":"Solid Elements Implementation","text":"","category":"section"},{"location":"theory/prinMechWork/#Tetrahedron-Solid-Element","page":"Virtual mechanical work ","title":"Tetrahedron Solid Element","text":"","category":"section"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"The tetrahedron element considered is a four-node linear element. The isoparametric coordinates reference element is shown in the following figure","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"(Image: )","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"and the linear shape functions are given by","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"N_1(xi) = xi_1 quad\nN_2(xi) = 1-xi_1-xi_2-xi_3 quad\nN_3(xi) = xi_3 quad\nN_4(xi) = xi_2","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"The functions can be expressed in vector form","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"  textbf N  = \n  left\nbeginmatrix\nN_1 \nN_2 \nN_3 \nN_4\nendmatrix\n  right","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"and the linear interpolation of the coordinates of any point within an element can be written as","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"textbfX = eleCoordMat  textbfN(xi)","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"where eleCoordMat is a matrix with the reference configuration coordinates (or material coordinates) of the nodes:","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"eleCoordMat =\nleft\nbeginmatrix\nX_11    X_12  X_13  X_14 \nX_21    X_22  X_23  X_24 \nX_31    X_32  X_33  X_34 \nendmatrix\nright","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"where X_ij represents the coordinate in the i-th dimension of the j-th node.","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"The displacements gradient tensor is defined as","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"  textbf H  =\n    frac partial textbf u  \n\t  partial textbf X  \n\t qquad\n  H_ij =  frac partial u_i   partial X_j ","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"and using the displacement interpolation can be written in matrix form as","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"textbf H  = eleDispsMat  fracpartial textbfN partial textbfX","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"The material-isoparametric coordinates relation is given by:","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"textbfX = eleCoordMat   textbf N (xi)","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"and using the chain rule we obtain:","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"fracpartial textbfN partial textbfX = \nfracpartial textbfN partial xi   fracpartial xi  partial textbfX  ","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"Then using the inverse theorem we obtain:","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"fracpartial xi partial textbfX = left( eleCoordMat   fracpartial textbfN partial xi  right)^-1","category":"page"},{"location":"theory/prinMechWork/","page":"Virtual mechanical work ","title":"Virtual mechanical work ","text":"nabla textbfu = eleDispsMat  left( eleCoordMat   fracpartial textbfN partial xi  right)^-1","category":"page"},{"location":"#ONSAS:-an-Open-Nonlinear-Structural-Analysis-Solver","page":"Home","title":"ONSAS: an Open Nonlinear Structural Analysis Solver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Join the chat at https://gitter.im/onsas_/community)","category":"page"},{"location":"#What-is-ONSAS?","page":"Home","title":"What is ONSAS?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ONSAS is a set of solvers for static/dynamic and linear/non-linear analysis of structures. The first version was developed for educational purposes and published in a Structural Analysis handbook. Currently different implementations and tools aimed for diverse applications are under development.","category":"page"},{"location":"#What-can-ONSAS-be-used-for?","page":"Home","title":"What can ONSAS be used for?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The current version allows to perform dynamic/static nonlinear analyses of beam/truss/solid 3D structures. A reduced list of features is listed at next:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Elements 2-node truss, 2-node Bernoulli frame, 4-node tetrahedron.\nStatic analysis methods Newton-Raphson Method and Cylindrical Arc-Length Method.\nDynamic analysis methods Newmark Method.\nLoads nodal loads, time-history user-defined loading program.","category":"page"},{"location":"#Some-examples","page":"Home","title":"Some examples","text":"","category":"section"},{"location":"#A-wind-turbine-model","page":"Home","title":"A wind turbine model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: wind)","category":"page"},{"location":"#A-tower-model","page":"Home","title":"A tower model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: tower)","category":"page"},{"location":"#A-chain-model","page":"Home","title":"A chain model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: chain)","category":"page"},{"location":"#Contributors-and-License","page":"Home","title":"Contributors and License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code is distributed under a GNU-GPL 3.0 license.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the full list of contributors and their affiliations in the Authors section.","category":"page"}]
}
