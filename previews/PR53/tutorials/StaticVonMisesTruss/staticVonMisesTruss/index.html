<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Static Von-Mises Truss · ONSAS.m</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="ONSAS.m logo"/></a><div class="docs-package-name"><span class="docs-autofit">ONSAS.m</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Static Von-Mises Truss</a><ul class="internal"><li><a class="tocitem" href="#MEBI-parameters"><span>MEBI parameters</span></a></li><li><a class="tocitem" href="#elements"><span>elements</span></a></li><li><a class="tocitem" href="#boundaryConds"><span>boundaryConds</span></a></li><li><a class="tocitem" href="#initial-Conditions"><span>initial Conditions</span></a></li><li><a class="tocitem" href="#mesh-parameters"><span>mesh parameters</span></a></li><li><a class="tocitem" href="#analysisSettings"><span>analysisSettings</span></a></li><li><a class="tocitem" href="#otherParams"><span>otherParams</span></a></li><li><a class="tocitem" href="#ONSAS-execution"><span>ONSAS execution</span></a></li></ul></li><li><a class="tocitem" href="../../uniaxialExtension/uniaxialExtension/">Uniaxial Extension Solid</a></li></ul></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../../howtouse/install/">Installation</a></li><li><a class="tocitem" href="../../../howtouse/creatingModels/">Creating Models</a></li></ul></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../../theory/prinMechWork/">Virtual mechanical work </a></li><li><a class="tocitem" href="../../../theory/prinTherWork/">Virtual thermal work</a></li><li><a class="tocitem" href="../../../theory/references/">References</a></li></ul></li><li><a class="tocitem" href="../../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Static Von-Mises Truss</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Static Von-Mises Truss</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ONSAS/ONSAS_docs/blob/master/docs/src/tutorials/StaticVonMisesTruss/staticVonMisesTruss.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Static-Von-Mises-Truss-example"><a class="docs-heading-anchor" href="#Static-Von-Mises-Truss-example">Static Von Mises Truss example</a><a id="Static-Von-Mises-Truss-example-1"></a><a class="docs-heading-anchor-permalink" href="#Static-Von-Mises-Truss-example" title="Permalink"></a></h1><hr/><p>In this tutorial, the Static Von Mises Truss example and its resolutions using ONSAS are described. The aim of this example is to validate the Newton-Raphson and the Arc-Length methods implementation by comparing the results provided by ONSAS with the analytical solution.</p><p>The structural model is formed by two truss elements as it is shown in the figure, with the node <span>$2$</span> submitted to a nodal load <span>$P$</span> and restrained to movement in the <span>$x-z$</span> plane and nodes <span>$1$</span> and <span>$3$</span> fixed.</p><p><img src="../vonMisesTruss.svg" alt="structure diagram"/></p><p>The Octave script is avaiable at: <a href="tutorials/StaticVonMisesTruss/">RUTA</a></p><p>Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar auxiliar parameters are defined.</p><pre><code class="language-none">close all, clear all ;
addpath( [ pwd &#39;/../../src&#39;] ); 
E = 210e9 ;  A = 2.5e-3 ; ang1 = 65 ; L = 2 ; nu = 0 ;
auxx = cos( ang1*pi/180 ) * L ;  auxz = sin( ang1*pi/180 ) * L ;</code></pre><h2 id="MEBI-parameters"><a class="docs-heading-anchor" href="#MEBI-parameters">MEBI parameters</a><a id="MEBI-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#MEBI-parameters" title="Permalink"></a></h2><hr/><p>The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions-InitialConditions (MEBI) parameters.</p><h3 id="materials"><a class="docs-heading-anchor" href="#materials">materials</a><a id="materials-1"></a><a class="docs-heading-anchor-permalink" href="#materials" title="Permalink"></a></h3><p>Since both bars are formed by the same material all the fields of the <code>materials</code> struct will have only one entry. contains only one vector. The constitutive behavior is the SaintVenantKirchhoff:</p><pre><code class="language-none">materials.hyperElasModel  = { &#39;SVK&#39;} ;</code></pre><p>and the parameters of this model are the Lamé parameters</p><pre><code class="language-none">lambda = E*nu/((1+nu)*(1-2*nu)) ; mu = E / (2*(1+nu));
materials.hyperElasParams = { [ lambda  mu  ] } ;</code></pre><h2 id="elements"><a class="docs-heading-anchor" href="#elements">elements</a><a id="elements-1"></a><a class="docs-heading-anchor-permalink" href="#elements" title="Permalink"></a></h2><p>Two different types of elements are considered, node and truss. The nodes will be assigned in the first entry (index <span>$1$</span>) and the truss at the index <span>$2$</span>. The elemType field is then:</p><pre><code class="language-none">elements.elemType = { &#39;node&#39;,&#39;truss&#39; } ;</code></pre><p>for the geometries, the node has not geometry to assign (empty array), and the truss elements will be set as a square-cross section, then the elemTypeGeometry field is:</p><pre><code class="language-none">elements.elemTypeGeometry = { [], [2 sqrt(A) sqrt(A) ] };
elements.elemTypeParams = { [], 1 };</code></pre><h2 id="boundaryConds"><a class="docs-heading-anchor" href="#boundaryConds">boundaryConds</a><a id="boundaryConds-1"></a><a class="docs-heading-anchor-permalink" href="#boundaryConds" title="Permalink"></a></h2><p>The elements are submitted to two different BC settings. The nodes <span>$1$</span> and <span>$3$</span> are fixed without applied loads (first BC), and node <span>$2$</span> has a constraint in displacement and an applied load (second BC).</p><pre><code class="language-none">boundaryConds.loadCoordSys = { []        ; &#39;global&#39;   } ;
boundaryConds.loadTimeFact = { []        ; @(t) 1.5e8*t     } ;
boundaryConds.loadBaseVals = { []        ; [ 0 0 0 0 -1 0 ] } ;
boundaryConds.impoDispDofs = { [ 1 3 5 ] ; 3          } ;
boundaryConds.impoDispVals = { [ 0 0 0 ] ; 0          } ;</code></pre><h2 id="initial-Conditions"><a class="docs-heading-anchor" href="#initial-Conditions">initial Conditions</a><a id="initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#initial-Conditions" title="Permalink"></a></h2><p>homogeneous initial conditions are considered, then an empty struct is set:</p><pre><code class="language-none">initialConds                = struct() ;</code></pre><h2 id="mesh-parameters"><a class="docs-heading-anchor" href="#mesh-parameters">mesh parameters</a><a id="mesh-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#mesh-parameters" title="Permalink"></a></h2><p>The coordinates of the nodes of the mesh are given by the matrix:</p><pre><code class="language-none">mesh.nodesCoords = [      0  0     0  ; ...
                       auxx  0  auxz  ; ...
                     2*auxx  0     0  ] ;</code></pre><p>The connectivity is introduced using the <em>conecCell</em>. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:</p><pre><code class="language-none">mesh.conecCell = { } ;</code></pre><p>then the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the <em>elements</em> struct), and the first entry of the cells of the boundary conditions struct. No non-homogeneous initial condition is considered (then zero is used) and finally the node is included.</p><pre><code class="language-none">mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1   ] ; 
mesh.conecCell{ 2, 1 } = [ 0 1 1 0  3   ] ; </code></pre><p>the following case only differs in the boundary condition</p><pre><code class="language-none">mesh.conecCell{ 3, 1 } = [ 0 1 2 0  2   ] ; </code></pre><p>the truss elements are formed by the first material, the second type of element, and no boundary condition is applied.</p><pre><code class="language-none">mesh.conecCell{ 4, 1 } = [ 1 2 0 0  1 2 ] ;
mesh.conecCell{ 5, 1 } = [ 1 2 0 0  2 3 ] ; </code></pre><h2 id="analysisSettings"><a class="docs-heading-anchor" href="#analysisSettings">analysisSettings</a><a id="analysisSettings-1"></a><a class="docs-heading-anchor-permalink" href="#analysisSettings" title="Permalink"></a></h2><pre><code class="language-none">analysisSettings.methodName    = &#39;newtonRaphson&#39; ;
analysisSettings.deltaT        = 0.1 ;
analysisSettings.finalTime     =   1 ;
analysisSettings.stopTolDeltau =   1e-6 ;
analysisSettings.stopTolForces =   1e-6 ;
analysisSettings.stopTolIts    =   10 ;
analysisSettings.finalTime     =   1 ;</code></pre><h2 id="otherParams"><a class="docs-heading-anchor" href="#otherParams">otherParams</a><a id="otherParams-1"></a><a class="docs-heading-anchor-permalink" href="#otherParams" title="Permalink"></a></h2><pre><code class="language-none">otherParams.problemName = &#39;staticVonMisesTruss_NR&#39;;
otherParams.plotParamsVector = [3];
otherParams.controlDofs = [2 5 ];</code></pre><h2 id="ONSAS-execution"><a class="docs-heading-anchor" href="#ONSAS-execution">ONSAS execution</a><a id="ONSAS-execution-1"></a><a class="docs-heading-anchor-permalink" href="#ONSAS-execution" title="Permalink"></a></h2><pre><code class="language-none">[matUs, loadFactorsMat] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><p>```</p><p>analyticFunc    = @(w) 2 * E * A * sin(ang1 * pi / 180 )^2 * w / L ;</p><p>numDisp =  -matUs(11,:) ;</p><p>figure plot( numDisp , loadFactorsMat(:,2) ,&#39;b&#39; ) hold on, grid on plot( numDisp , analyticFunc( numDisp),&#39;r&#39; )</p><p>l0           = sqrt(auxx^2 + auxz^2) ; analyticFunc = @(w) -2 * E<em>A</em> ( (  (auxz+(-w)).^2 + auxx^2 - l0^2 ) ./ (l0 * ( l0 + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ...             .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  hold on, grid on plot( numDisp , analyticFunc( numDisp), &#39;g&#39; )</p><p>% =============================================== % methods comparison % ==================================== % second case: newton raphson analysis % =============================================== % third case: NRarc-length analysis with dxf mesh % ––––––––––––––––––––––––––––––––––– % –- plots – %l0           = sqrt(auxx^2 + auxz^2) ; % analyticFunc = @(w) -2 * E<em>A</em> ( (  (auxz+(-w)).^2 + auxx^2 - l0^2 ) ./ (l0 * ( l0 + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ... % .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  % %% analytical solution using engineering strain % analyticFunc = @(w)  -2 * E<em>A</em> ( (  (auxz+(-w)).^2 + auxx^2 - l0^2 ) ./ (l0 * ( l0 + sqrt((auxz+(-w)).^2 + auxx^2) )) ) ...  %~ .* (auxz+(-w)) ./ ( sqrt((auxz+(-w)).^2 + auxx^2) )  ;  % %~ lw = 2.0 ; ms = 11 ; plotfontsize = 22 ; %~ figure %~ plot( controlDispsNRAL, analyticNRAL ,&#39;b-x&#39; , &#39;linewidth&#39;, lw,&#39;markersize&#39;,ms ) %~ hold on, grid on %~ plot( controlDispsNRAL, loadFactorsNRAL,&#39;r-s&#39; , &#39;linewidth&#39;, lw,&#39;markersize&#39;,ms ) %~ plot( controlDispsNR, loadFactorsNR,&#39;k-o&#39; , &#39;linewidth&#39;, lw,&#39;markersize&#39;,ms ) %~ labx = xlabel(&#39;Displacement&#39;);   laby = ylabel(&#39;<span>$\lambda$</span>&#39;) ; %~ legend(&#39;analytic&#39;,&#39;NRAL-DXF&#39;,&#39;NR&#39;,&#39;location&#39;,&#39;North&#39;) %~ set(gca, &#39;linewidth&#39;, 1.2, &#39;fontsize&#39;, plotfontsize ) %~ set(labx, &#39;FontSize&#39;, plotfontsize); set(laby, &#39;FontSize&#39;, plotfontsize) ;</p><p>%~ [verifBoolean, numericalVals, analyticVals] = analyticSolVerif ...     %~ ( analytSol, analyticFunc, loadFactors, controlDisps, timesVec, ...     %~ analyticCheckTolerance, analyticSolFlag, problemName, printFlag, outputDir, plotParamsVector );</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Home</a><a class="docs-footer-nextpage" href="../../uniaxialExtension/uniaxialExtension/">Uniaxial Extension Solid »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 March 2021 13:48">Thursday 4 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
